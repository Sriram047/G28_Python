# -*- coding: utf-8 -*-
"""G28 Python Mini Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v-1-DdqNJQ0FKA8VVPZl0nd9iaK_EBry

**Title**: Restaurant Order System

**Description**: Manage menu items, orders, tables, etc.

**Classes:** You can create classes for MenuItem, Order, and Table. Each class would have appropriate attributes. For example, the MenuItem class could have name, price, etc. as attributes.

**Variables & Input from User:** You’ll need to take inputs from the user for various operations like adding a new menu item, creating an order, assigning an order to a table, etc.

**Datatypes:** You’ll be working with different datatypes like strings (for names), integers (for table numbers), floats (for prices), lists (for storing multiple orders or menu items), etc.

**Type Conversions**: There might be cases where you’ll need to convert datatypes, like converting user input to integer for table numbers or to float for prices.

**Operators**: You’ll use operators for comparisons (like checking if a table number exists) and arithmetic (like calculating the total price of an order).

**Conditional & Iterative Statements**: These will be used for creating the logic of your program. For example, you can use conditional statements to check if a table is available.

Strings: These will be used for storing and manipulating text data like names.

**Inbuilt Data Structures in Python**: You can use lists to store multiple orders, tables, menu items, etc., and dictionaries to store attributes of orders, tables, etc.

**Functions**: You can create functions for different operations like adding a new menu item, creating an order, assigning an order to a table, etc.

**OOPS**: This project is a great way to apply Object-Oriented Programming concepts. Each entity like MenuItem, Order, Table can be represented as a class with their own attributes and methods.

**Files**: You can use file handling to store data permanently. For example, you can store all the menu items’ data in a file.

**Exception Handling**: This will be used to handle any runtime errors in your program and improve its robustness.
"""

class MenuItem:
    def __init__(self, name, price, description):
        self.name = name
        self.price = price
        self.description = description

class Order:
    def __init__(self):
        self.items = []

    def add_item(self, item):
        self.items.append(item)

    def calculate_total(self):
        total = sum(item.price for item in self.items)
        return total

class Table:
    def __init__(self, number):
        self.number = number
        self.status = 'vacant'
        self.order = None

    def assign_order(self, order):
        self.order = order
        self.status = 'occupied'

# Sample menu items
menu_items = [
    MenuItem("Burger", 9.99, "A delicious burger"),
    MenuItem("Pizza", 12.99, "A classic pizza"),
    MenuItem("Salad", 5.99, "A fresh salad"),
]

# Initialize tables
tables = [Table(1), Table(2), Table(3)]

def display_menu():
    print("Menu:")
    for i, item in enumerate(menu_items, start=1):
        print(f"{i}. {item.name} - ${item.price} - {item.description}")

def create_order():
    order = Order()
    display_menu()
    while True:
        try:
            item_number = int(input("Enter the item number to add (0 to finish): "))
            if item_number == 0:
                break
            elif 1 <= item_number <= len(menu_items):
                order.add_item(menu_items[item_number - 1])
            else:
                print("Invalid item number. Please try again.")
        except ValueError:
            print("Invalid input. Please enter a valid item number.")
    return order

def main():
    while True:
        print("\nTables:")
        for table in tables:
            print(f"Table {table.number} - Status: {table.status}")

        table_number = int(input("Enter a table number to assign an order (0 to exit): "))
        if table_number == 0:
            break
        elif 1 <= table_number <= len(tables):
            if tables[table_number - 1].status == 'vacant':
                order = create_order()
                tables[table_number - 1].assign_order(order)
                print(f"Order assigned to Table {table_number}")
            else:
                print(f"Table {table_number} is already occupied.")
        else:
            print("Invalid table number. Please try again.")

if __name__ == "__main__":
    main()

elif 1 <= table_number <= len(tables):